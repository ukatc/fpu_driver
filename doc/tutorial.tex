\documentclass{scrartcl}[12pt,a4paper]
%\documentclass{article}[12pt,a4paper]
%\documentclass{artikel3}[12pt,a4paper]

\usepackage{minted}
\usepackage{hyperref}


\begin{document}

\title{FPU driver Python library Tutorial}
\subtitle{For driver version 0.5.0}

\author{Johannes Nix}

\maketitle

\tableofcontents


\section{Introduction}
\subsection{Topic and goals}
This tutorial describes how to use the Python bindings for the MOONS
fibre positioner unit (FPU) driver. Its goal is to enable the reader
to control the FPU in the verification system using python scripts, so
that he or she can perform basic verification tasks.


\subsection{Required knowledge}

It is assumed that the reader has basic knowledge of either Python or
a similar object-oriented language, like Java or c\#.  In the case
that using Python and scripts is completely new to the reader, it is
probably helpful to consult the tutorial for Python 2.7 at
\url{https://docs.python.org/2.7/tutorial/}.  Both the current version
of the driver as well as this document use Python 2.7, which has some
differences to Python 3. However this introduction does so in a way
that differences to Python 3 are minimized.

Also, in order to retrieve the current version of the library,
the user needs to have a minimum knowledge of the git version
control system. This is explained, for example, in \url{https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository}.

\subsection{Setting up the library module}

\subsubsection{Getting the source code}

To set up the library module, it is first
necessary to retrieve a current copy of its source code.
On the moons-pc01 workstation, this can be done using the
command \mint{bash}|git clone /home/jnix/fpu_driver|.
This creates a new directory with the name \texttt{fpu\_driver}
and populates it with the source code.

Alternatively, a fresh copy can be retrieved from the UKATC dalriada
server. Doing this this requires a personal user account on that
server. Assuming the account name is \texttt{carl}, this is done by
the command

\mint{bash}|git clone carl@dalriada/sw/sw4/jnix/MOONS/fpu_driver|

After entering the password for user \texttt{carl}, the
source code is copied into the new folder \texttt{fpu\_driver}.

\subsubsection{Refreshing the source code}
To refresh the source code, change the
working directory to \texttt{fpu\_driver},
and issue the command

\mint{bash}|git pull|

\subsubsection{Building the library module}

To build the Python library module,
change the working directory to \texttt{fpu\_driver},
and issue the command \mint{bash}|make pyext|

In order for this to work, the required dependencies need to be
installed. For the MOONS workstation, this is always the case. To
install these dependencies on other computers, follow the detailed
instructions in the file ``\texttt{doc/INSTALL}''.

\subsubsection{Environment configuration}

For the Python module to work, the directory \texttt{/user/local/lib}
needs to be added to the environment variable
\texttt{LD\_LIBRARY\_PATH}.  Assuming a standard setup, this can be
done by adding the following line to the file \texttt{.bashrc} in the
home directory:

\texttt{export LD\_LIBRARY\_PATH=\$LD\_LIBRARY\_PATH:/usr/local/lib}.

All the examples presented here assume that the current working
directory is \texttt{fpu\_driver/python}. If this is not the case,
this directory needs to be added to the \texttt{PYTHONPATH}
environment variable.


\subsection{Communication protocol versions}

The FPU driver sends commands to the fibre positioner units, which use
a specific communication protocol.  The current version of the driver
(version 0.5.0) uses communication protocol version 1, which has some
restrictions in functionality. For example, some edge cases cannot be
checked, some operations might take longer, and some errors are not
recognized and cannot be easily worked around. The main significant
difference which is visible to the users of the FPU driver module is
that cases in which the alpha arm of the FPU hits the limit switch
need to be manually recovered from. This is explained in
section\ref{sec:recovery} on page \pageref{sec:recovery}.


\section{A minimal example}

The following listing shows a minimal example of the
driver usage, and explains the underlying concepts
step by step.

\begin{minted}[linenos]{python}

from __future__ import print_function
import FpuGridDriver
from FpuGridDriver import TEST_GATEWAY_ADRESS_LIST
from fpu_commands import *

NUM_FPUS = 1
gd = FpuGridDriver.GridDriver(NUM_FPUS)

print("initializing driver: ", gd.initializeDriver())
print("connecting grid:", gd.connect(address_list=TEST_GATEWAY_ADRESS_LIST))


print("getting grid state:")
grid_state = gd.getGridState()


print("issuing findDatum:")
gd.findDatum(grid_state)
print("findDatum finished")

# We use grid_state to display the starting position
print("the starting position (in degrees) is:", list_angles(grid_state))


# Generate a waveform which moves the alpha arm by +45
# degree, and the beta arm by +15 degree. 

alpha_move = 45
beta_move = 15

# Generate the required waveform for one FPU
waveform = gen_wf(alpha_move, beta_move)

# upload the waveform to the FPU
gd.configMotion(waveform, grid_state)

# start the movement
print("starting movement by (45,15) degree")
gd.executeMotion(grid_state)

print("the reached position (in degrees) is:", list_angles(grid_state))

print("ready")

\end{minted}


\subsection{Import statements}

The import statements in lines 1 -- 4 load the following modules and
configurations:

\begin{itemize}
\item In line 1, the print function and the division operator is
  configured to work as in Python 3.
  
\item ``\texttt{import FpuGridDriver}'' in line 2 loads the driver
  object.

\item The line ``\texttt{from FpuGridDriver import
  TEST\_GATEWAY\_ADRESS\_LIST}'' loads a default address which refers to
  the EtherCAN gateway which is used. This address will be different
  when one wants to select a different gateway.

\item The line ``\texttt{from fpu\_commands import *}'' imports a few
  utility commands which help to display positions and to generate
  movement waveforms.

 
\end{itemize}

\subsection{Grid driver object}

In line 6, the used number of FPUs is set to one, and in line 7, the
FPU grid driver is initialized with that value. The returned object,
which is referenced by the Python variable \texttt{gd}, is always
required to access the FPUs.

\subsection{Driver methods}

The driver objects allows to issue method calls. The method names
always start with a dot after the name of the driver object.  So,
\texttt{gd.abc()} would call method ``abc'' of the driver object. Like
normal function calls, they usually have parameters. More concretely,
two methods are used to set up the driver:

\begin{description}
\item[\texttt{initializeDriver()}] initializes the driver object so
  that it can be used. This method needs to be called always at
  beginning.

\item[\texttt{connect()}] connects the driver to one or more EtherCAN
  gateways and starts listening to messages from the FPUs. The
  parameter defines to \emph{which} gateways the driver listens to.

\end{description}

As can be seen in the example, the methods have return values.  In
case of serious errors, the methods raise exceptions, as is the style
in Python.

the Python program does not need to explicitly disconnect
and de-initialize the driver, this happens automatically
when the program terminates\footnote{However if required, there
are methods which do that, too!}.



\subsection{Grid state variable}

Almost all commands to the driver return a snapshot of the current
state of the used FPU (or, if there are several, of all of them). That
snapshot is passed in the variable \texttt{grid\_state}. This variable
contains all the information a user might need about the state of the
FPUs - their current positions, which commands they will accept,
whether there are any collisions, whether the step counters have been
zeroed, whether a limit switch was hit, and so on. With each
invocation of a method, the old grid state is passed as a parameter,
and its new value is returned in the same variable.

To retrieve a current grid state information, the method
``getGridState()'' is used, as is done in line 14. In our listing, the
grid state variable is assigned to the variable \texttt{grid\_state}.
The \texttt{getGridState()} function always returns immediately, as it
just takes a snapshot. Because \texttt{grid\_state} is used so
frequently, a short-hand which many other programs use is the name
\texttt{gs}.

\subsection{Moving the FPU around}

The program then proceeds to use three methods to move
the FPUs:

\begin{description}
\item[\texttt{findDatum()}] moves the FPU to the datum position. After this,
  the internal step counters are set to zero, both for the alpha and
  for the beta arm.

\item[\texttt{configMotion()}] is a method which sends a table with movement
  operations, also called waveform table, to the FPU. In the listing,
  this is done in line 35. The movement table is stored in the
  variable \texttt{waveform}, which is defined in line 32.

\item[\texttt{executeMotion()}] is the command which starts the movement of the
  FPU. This command returns when the movement is complete and the FPUs
  have stopped to move. In case of an error, the command generates a
  Python exception.

\end{description}

\subsection{Utility functions}

The example also shows two utility functions for generating movement
data, and displaying information about the FPU state:

\begin{description}
\item[\texttt{list\_angles()}] is a function which takes a \texttt{grid\_state}
  variable, and displays the approximate positions of the FPUs as
  alpha and beta angles, in degree units.

\item[\texttt{gen\_wf()}] is a function which takes an (alpha,beta)
  value pair, and generates a valid waveform which can be send to the
  FPU.  The waveform which is passed is a regular Python data
  structure and can be displayed and manipulated like any other Python
  object.  The user only needs to be careful that it contains valid
  movement data when it is passed to the \texttt{configMotion()}
  method!

\end{description}



\section{Common tasks}

\subsection{Checking the connection}
\subsection{Getting the current position}
\subsection{Moving the FPU to the datum position}
\subsection{Moving the FPU}
\subsubsection{Moving by an angle}
\subsubsection{Defining a waveform table}

\subsection{Aborting a movement}

\subsection{Repeating a movement}
\subsection{Reversing a movement}

\section{Recovery from collisions and limit breaches}
\label{sec:recovery}

\subsection{What happens when a collision or limit switch breach occurs}
\subsection{Limitations of firmware version 1}

\section{Reference}
\subsection{Commands}
\subsection{Errors}
\subsection{State Machine}


\end{document}
