
* TODO Design questions

** TODO subobjects for CAN gateways
** TODO command protocol

** TODO naming of classes
- class for CAN Bus level object GatewayDriver
- class for whole grid of FPUs GridDriver (to avoid clash with Python library)

* TODO code CAN driver

** DONE file preamble
** DONE write class skeleton
- [X] add members
  - [X] state array
  - [X] struct: ready, pending and error counters
  - [X] socket
  - [X] read and write buffers
  - [X] condition variable
  - [X] state mutex
  - [X] sending and receiving threads


- [X] initialisation / constructor / destructor code
  - [X] state array
  - [X] struct: ready, pending and error counters
  - [X] socket
  - [X] read and write buffers
  - [X] condition variable
  - [X] state mutex
  - [X] sending and receiving threads

- [X] state enumeration
** DONE handle byte stuffing better
** DONE socket handling using poll()

** DONE define E_GridState enumeration

** DONE define some Error codes for CAN driver
** DONE look up timing functions
** DONE split off code thread-safe FPUStates Array
*** DONE getGridState method
*** DONE waitForState method
*** DONE getNextTimeOut method
*** DONE CommandID submember
*** DONE state counters
*** DONE addTimeOut method
*** DONE clearTimeOut method
*** DONE Fix wait states and error fields
*** DONE bind result into receive loop
*** DONE write FPUArray::process_timeouts()
*** DONE fix time_spec functions and signatures
** DONE code thread-safe CommandQueue
*** DONE waitForCommand method
*** DONE getCommandMask
*** DONE pushCommand method
*** DONE popCommand method
** DONE define time quantization
** DONE Set grid state on disconnect, and signal to Wait()
** DONE Normalize timespecs (set_normalized_timespec, -> 
time_spec_add_safe), also  use TIME_T_MAX from time.h)
** DONE Base CommandQueue length on NUMFPUS * 256, 
  for the wavetable loading
** DONE Define two enums for the CAN driver:
 one for the driver state, and one for 
 the last error
** DONE command interface (draft)
** DONE command serialisation
- [ ] does that need a class and interface?
** DONE response handler interface
*** DONE read Pablo's sample for hints
*** DONE ask Pablo about sync0 and sync1
*** DONE read about priorities / canids
*** DONE Sample response handler and ping message
** DONE code thread-safe CommandPool (memory pool)
** DONE termination / synchronization
*** DONE mask SIGPIPE signal
*** DONE use counter of still running threads?
*** DONE use atomic usage count for socketfd for clean termination
*** DONE issue shutdown() before close()
** DONE Fix memory leak on exiting tx loop
** DONE add condition variable to pop cmdqueue
** DONE add comment to wait on pop
** DONE Error handling of syscalls
*** DONE check errno as soon as possible, anywhere
** A few Top-level calls (just as example)
*** DONE Top-level calls
*** DONE check count of pending states
** TODO Move workstation
** TODO compile
*** TODO write makefile
** TODO Add tentative CAN responses
*** TODO config_motion
*** TODO ping
*** TODO searchDatum
*** TODO leaveDatum
* TODO Improvements
** DONE fix name field in header
** TODO put commands in namespace
** TODO put can level stuff into namespace

** TODO split methods in initialize() / uninitialize():
  anywhere we allocate memory via the STL, to catch
  out-of-memory exceptions

  Also, thread tghrough the calls of these methods
  up to the top level.
** TODO Clean-up
*** TODO collect time utility functions into own file
*** TODO replace hand-rolled time function with system standard funcs
*** DONE consider: move locus of time-stamping sent command to after termination of sending
*** TODO split SBuffer in independent read buffer and write buffer
*** TODO Split declarations and implementations into source files as usual
** TODO compile -Wall
** TODO separate locked operation and reporting/logging of results
** TODO make API const-correct
** TODO API methods hould return state reference parameter
.. in output argument. This requires an additional lock
when the internal state struct is used.

